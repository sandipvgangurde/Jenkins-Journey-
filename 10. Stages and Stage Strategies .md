# ğŸ”¥ **Mastering Stages and Stage Strategies**

### **The Foundation of Scalable Pipelines** ğŸ—ï¸

---

### **1. What Are Stages?** ğŸ—ï¸

A **stage** in Jenkins represents a significant step in your CI/CD pipeline (like **Build**, **Test**, **Deploy**, etc.).

Stages help you organize your pipeline logically, and they can run either **sequentially** or **in parallel**.

#### **Basic Pipeline Example:**

```groovy
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                echo "Building the project"
            }
        }
        
        stage('Test') {
            steps {
                echo "Running tests"
            }
        }
        
        stage('Deploy') {
            steps {
                echo "Deploying to production"
            }
        }
    }
}
```

**Explanation:**

* This example defines a **simple sequential pipeline** where each stage runs **one after the other**.

---

### **2. Creating Multiple Stages** ğŸ“„

When your pipeline involves multiple tasks, youâ€™ll need to create **multiple stages** to break them down into logical chunks. This makes the pipeline more **readable** and **maintainable**.

#### **Pipeline with Multiple Stages:**

```groovy
pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                echo "Building project..."
                sh './gradlew build'
            }
        }

        stage('Test') {
            steps {
                echo "Running tests..."
                sh './gradlew test'
            }
        }

        stage('Package') {
            steps {
                echo "Creating artifact..."
                sh './gradlew assemble'
            }
        }

        stage('Deploy to Staging') {
            steps {
                echo "Deploying to staging..."
                sh './deploy.sh staging'
            }
        }

        stage('Deploy to Production') {
            steps {
                echo "Deploying to production..."
                sh './deploy.sh prod'
            }
        }
    }
}
```

#### **Pipeline Flow Diagram:**

```
[ Build ] â” [ Test ] â” [ Package ] â” [ Deploy to Staging ] â” [ Deploy to Production ]
```

---

### **3. When to Split Stages?** ğŸ¤”

You should **split stages** when tasks become **complex**, **parallelizable**, or **dependent** on each other.

#### **Example: Split for Clarity & Efficiency**

Imagine you have a complex pipeline for **testing**. You might want to **split** the tests into **unit** and **integration** tests, and run them **in parallel**.

```groovy
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                echo "Building..."
                sh './build.sh'
            }
        }
        
        stage('Tests') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        echo "Running Unit Tests"
                        sh './unit-tests.sh'
                    }
                }
                stage('Integration Tests') {
                    steps {
                        echo "Running Integration Tests"
                        sh './integration-tests.sh'
                    }
                }
            }
        }
        
        stage('Deploy') {
            steps {
                echo "Deploying..."
                sh './deploy.sh'
            }
        }
    }
}
```

#### **Parallel Test Execution:**

```
[ Unit Tests ] ğŸƒâ€â™‚ï¸
[ Integration Tests ] ğŸƒâ€â™‚ï¸
```

Here, both **Unit Tests** and **Integration Tests** will run **in parallel**, reducing the overall pipeline time.

### Practice Example : 

### Link of the practive code : [Click here for the code](https://github.com/sandipvgangurde/Jenkins-Journey-/blob/main/Test-Codes/01.%20Parallel-code%20.md)

###This is how the real world pipeline will looks like

<img width="1875" height="1023" alt="image" src="https://github.com/user-attachments/assets/8fdf1641-a6ae-4e57-972e-880a203d4925" />

---

### **4. Stage-Level Options** ğŸ”§

Each stage can have its own specific options like **timeout**, **retry**, and **conditional execution**. This helps you control **how and when** a stage runs.

#### **a. `when` â€“ Conditional Execution** ğŸ”„

You can run a stage **only if a condition is met**. For example, run deployment only on the `master` branch.

```groovy
stage('Deploy to Production') {
    when {
        branch 'master'
    }
    steps {
        echo "Deploying to Production"
    }
}
```
### Practice Code : [When Code](https://github.com/sandipvgangurde/Jenkins-Journey-/blob/main/Test-Codes/02.%20when-code.md)

### This is how the when will skip the non-matched enviroment : 

<img width="1892" height="1035" alt="image" src="https://github.com/user-attachments/assets/aceb3f60-48d3-42b8-be5c-2c294ed67b67" />



* **Explanation**: This stage will only run if the pipeline is triggered by the `master` branch.

#### **b. `timeout` â€“ Set Timeout for a Stage** â°

To prevent stages from hanging indefinitely, you can set a **timeout**.

```groovy
stage('Test') {
    timeout(time: 30, unit: 'MINUTES') {
        steps {
            sh './run-tests.sh'
        }
    }
}
```

* **Explanation**: The `Test` stage will **time out** after 30 minutes if it hasnâ€™t completed yet.

#### **c. `retry` â€“ Retry a Stage if it Fails** ğŸ”

You can automatically **retry** a stage if it fails.

```groovy
stage('Deploy') {
    retry(3) {
        steps {
            sh './deploy.sh'
        }
    }
}
```

* **Explanation**: The `Deploy` stage will **retry** up to **3 times** if it fails.

#### **d. `post` â€“ Post Actions** ğŸ”š

You can define **actions** that should occur after a stage completes, regardless of whether it was successful or not.

```groovy
stage('Test') {
    steps {
        echo "Running tests..."
    }
    post {
        success {
            echo "Tests passed!"
        }
        failure {
            echo "Tests failed!"
        }
    }
}
```

---

### **5. Sequential vs. Parallel Stages** ğŸš¦

#### **Sequential Stages** ğŸš¶â€â™‚ï¸

By default, Jenkins runs stages **sequentially**, one after the other.

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo "Building..."
            }
        }
        stage('Test') {
            steps {
                echo "Testing..."
            }
        }
        stage('Deploy') {
            steps {
                echo "Deploying..."
            }
        }
    }
}
```

**Diagram of Sequential Execution:**

```
[ Build ] â” [ Test ] â” [ Deploy ]
```

#### **Parallel Stages** ğŸƒâ€â™‚ï¸ğŸ’¨

You can run stages **in parallel** to **speed up** the pipeline when tasks are independent of each other.

```groovy
pipeline {
    agent any
    stages {
        stage('Build and Test') {
            parallel {
                stage('Build') {
                    steps {
                        echo "Building..."
                    }
                }
                stage('Test') {
                    steps {
                        echo "Running tests..."
                    }
                }
            }
        }
    }
}
```

**Diagram of Parallel Execution:**

```
[ Build ] ğŸƒâ€â™‚ï¸    [ Test ] ğŸƒâ€â™‚ï¸
      â†˜ï¸     â†˜ï¸     â†˜ï¸
      Parallel Execution
```

---

### **6. Stage Strategies Tree Diagram** ğŸŒ³

Letâ€™s visualize how to organize **sequential** vs **parallel** stages:

```
Pipeline ğŸŒŸ
 â”œâ”€â”€ Sequential Stages ğŸš¶â€â™‚ï¸
 â”‚   â”œâ”€â”€ Build 
 â”‚   â”œâ”€â”€ Test
 â”‚   â””â”€â”€ Deploy
 â”‚
 â”œâ”€â”€ Parallel Stages ğŸƒâ€â™‚ï¸
 â”‚   â”œâ”€â”€ Test 1 ğŸ§ª
 â”‚   â””â”€â”€ Test 2 ğŸ§ª
 â”‚
 â””â”€â”€ Mixed Stages ğŸ”„
     â”œâ”€â”€ Build
     â”œâ”€â”€ Test (Parallel: Test1, Test2)
     â””â”€â”€ Deploy
```

---

### **7. Conditional Parallel Execution** ğŸ§

Sometimes, you want to **conditionally run parallel stages** based on certain **criteria**. For example, you might only want to run the **Production deployment** if the pipeline is triggered by the `master` branch.

```groovy
pipeline {
    agent any
    stages {
        stage('Deploy') {
            parallel {
                stage('Staging Deploy') {
                    when {
                        branch 'staging'
                    }
                    steps {
                        echo "Deploying to Staging"
                    }
                }
                stage('Prod Deploy') {
                    when {
                        branch 'master'
                    }
                    steps {
                        echo "Deploying to Production"
                    }
                }
            }
        }
    }
}
```

---

### **8. Advanced Stage Strategies** ğŸ”§

#### **a. Matrix Pipelines** ğŸ“Š

A **matrix** allows you to **run tests** across multiple combinations of **environments** (e.g., operating systems, browsers).

```groovy
pipeline {
    agent any
    stages {
        stage('Test') {
            matrix {
                axes {
                    axis {
                        name 'OS'
                        values 'Ubuntu', 'Windows'
                    }
                    axis {
                        name 'BROWSER'
                        values 'Chrome', 'Firefox'
                    }
                }
                stages {
                    stage('Run Tests') {
                        steps {
                            echo "Running tests on ${OS} with ${BROWSER}"
                        }
                    }
                }
            }
        }
    }
}
```

---

### **9. Final Flow Chart** ğŸ“Š

To summarize everything weâ€™ve learned, hereâ€™s a **complete flow**:

```
+---------------------+          +
```
